---
layout: post
title: 'OpenID Connect - Dotnet Desktop Application'
date: 2023-05-13 18:00:00.000000000 -05:00
tags:
- dotnet
- programming
permalink: "/2023/05/13/openid-connect-dotnet-desktop-application/"
---
Recently, I've been deep diving into JSON Web Tokens (JWT) and the OpenID Connect protocols.
My end goal was to be able to use the OpenID Connect Authorization Flow to add authentication and authorization to a native desktop application using Dotnet.

The basic authentication workflow for a native/desktop/console/ application is as follows ([RFC 8252 Section 4.1](https://datatracker.ietf.org/doc/html/rfc8252#section-4.1)):

1. Application retrieves the following from the Authorization Server's OpenID Connection Configuration Endpoint:
    - Signing Keys
    - Authorization Endpoint
    - Token Endpoint
1. Application opens the system default browser to the Authorization Endpoint URI including the following details as query string parameters:
    - Response Type = "code"
    - Client ID
    - Redirect URI
    - Scope (Must include at least `openid`)
    - State (Secure random value)
    - Code Challenge
    - Code Challenge Method
1. Authorization Server's Authorization Endpoint receives the authorization request and then authenticates and authorizes the user.
1. Authorization server issues an authorization code and redirects the browser to the specified Redirect URI with the response appended to it.
1. Application receives the Redirect URI and retrieves the authentication code.
1. Application sends the authentication code to the Token Endpoint including the following details:
    - Grant Type = "authorization_code"
    - Client ID
    - Authentication Code
    - Redirect URI
    - Code Verifier
1. Authorization server validates the authorization code and issues the ID and Access Tokens.
1. Application validates the ID Token using the Signing Keys obtained previously.

There is a lot to unpack in each of these steps but we will cover everything as we implement them.

<!--more-->
<a name="more" />

## Configuring the Authentication Server

Since I am mainly focusing on the client-side of things for this round of investigation, [Auth0](https://auth0.com) provided a great starting point for the server-side of things as it fully supports the [OpenID Connect Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow).
You can quickly sign up for a free account that gives you plenty of capabilities to get started.

* Sign up for an [Auth0](https://auth0.com) account.
* Create a new Native Application (Mobile, desktop, CLI)
* Copy down the `Domain` and `Client ID` listed on the Settings tab.
* Set the `Callback URLs` to: `http://127.0.0.1:49152/callback, http://[::1]:49152/callback`
* Set the `Allowed Web Origins` to: `http://127.0.0.1:49152, http://[::1]:49152`
* Create two roles: Admin, Guest
* Create a test user with the Admin role.

The following values are used for all example outputs below:

* Domain: dev-MyDotnetApplication.us.auth0.com
* Client ID: OiCPeU0i214x6nJUq4YG4ECUlPOSUAlt

### Auth0 User Roles

Auth0 does not add the roles to the ID Token JWT by default.  We will use a [login action workflow](https://auth0.com/docs/manage-users/access-control/sample-use-cases-actions-with-authorization#add-user-roles-to-tokens) to automatically add the roles as custom namespaced claims to the ID and Access tokens that are generated by Auth0:

```javascript
exports.onExecutePostLogin = async (event, api) => {
  const namespace = event.client.client_id;

  if (event.authorization) {
    // Set claims 
    api.idToken.setCustomClaim(`${namespace}/roles`, event.authorization.roles);
    api.accessToken.setCustomClaim(`${namespace}/roles`, event.authorization.roles);
  }
};
```

Note: We are using the `Client ID` from the authorization request as the namespace because the "roles" claim is [restricted](https://auth0.com/docs/secure/tokens/json-web-tokens/create-custom-claims#general-restrictions) by Auth0 and cannot be set by the login actions.  If you try, it will be silently ignored and the token will be untouched.
If our `Client ID` was "XYZ123" then a custom claim "XYZ123_roles" will be added for each role.


## Create the Dotnet Console Application

For simplicity we will be using a Dotnet Console Application but the same workflow and implementation can work for User Interface applications as well.

From a command line execute the following to create the console application project:

```shell
dotnet new worker -n OpenIdConnectConsoleTest
cd OpenIdConnectConsoleTest
dotnet new class -n AuthenticationSettings
dotnet add package Microsoft.IdentityModel.Protocols.OpenIdConnect
```

We will be using the models defined in `System.IdentityModel.Tokens.Jwt` since Microsoft has already provided the proper DTO classes that are needed to deserialize the requests and validate a JWT.
We could create each one on our own but the models are just simple classes with the required properties so we would just be duplicating the effort.

The same thing goes for `Microsoft.IdentityModel.Protocols.OpenIdConnect` which contains the DTO classes for working with the OpenID Connect protocol.

Edit `AuthenticationSettings.cs` with the following contents:

```csharp
namespace OpenIdConnectConsoleTest;
public class AuthenticationSettings
{
    public string Audience { get; set; } = string.Empty;
    public string Authority { get; set; } = string.Empty;
    public string ClientId { get; set; } = string.Empty;
    public string RedirectUriPath { get; set; } = "callback";
    public int RedirectUriPort { get; set; } = 0;
}
```

We will use the `dotnet user-secrets` command to setup the configuration for items we need.
Execute the following from a command line from the project folder with the placeholders replace with your Auth0 values from earlier:

```shell
dotnet user-secrets set "Authentication:Authority" "https://{Auth0 Domain}/"
dotnet user-secrets set "Authentication:ClientId" "{Auth0 Client ID}"
dotnet user-secrets set "Authentication:RedirectUriPort" "49152"
```
Edit `appsettings.Development.json` and change the `Logging:LogLevel:Default` value to `Debug`.
There is lot of debug logging in the example code below so you can view responses.
In a real world application you should not log any sensitive information such as tokens.

### Worker.cs Class

Edit `Worker.cs` and add the following `using` clauses:

```csharp
using Microsoft.IdentityModel.Protocols;
using Microsoft.IdentityModel.Protocols.OpenIdConnect;
using Microsoft.IdentityModel.Tokens;
using System.Diagnostics;
using System.IdentityModel.Tokens.Jwt;
using System.Net;
using System.Net.Sockets;
using System.Runtime.InteropServices;
using System.Security.Claims;
using System.Security.Cryptography;
using System.Text;
using System.Text.Encodings.Web;
```

Add the following lines above the `ILogger` private property:

```csharp
private readonly AuthenticationSettings _authSettings;
private readonly IHostApplicationLifetime _hostApplicationLifetime;
private readonly static HttpClient _httpClient = new();
```

Update the constructor:

```csharp
public Worker(
    ILogger<Worker> logger,
    IHostApplicationLifetime hostApplicationLifetime,
    IConfiguration configuration)
{
    _logger = logger;
    _hostApplicationLifetime = hostApplicationLifetime;
    _authSettings = configuration.GetSection("Authentication").Get<AuthenticationSettings>() ?? new AuthenticationSettings();
}
```

`_authSettings` will contain all of the configuration options that we need from the `Authentication` section.
This will come from the values that we stored in user-secrets previously.  `_hostApplicationLifetime` will be used to terminate the console application when required.

### ExecuteAsync Method

The Worker class is instantiated on startup as a Hosted BackgroundService.
The lifetime of our console application will be based on the WorkerService.
Once the ExecuteAsync method finishes executing, the console application will end.

Edit `Worker.cs` and change `ExecuteAsync` to the following:

```csharp
protected override async Task ExecuteAsync(CancellationToken stoppingToken)
{
    try
    {
        ClaimsPrincipal user = await AuthenticateExternalUserAsync(stoppingToken);
        var userId = user.Claims?.FirstOrDefault(c => c.Type == "sub")?.Value;
        var email = user.Claims?.FirstOrDefault(c => c.Type == "email")?.Value;

        _logger.LogInformation("Authenticated as Id: {userId} Name: {name} Email: {email} Claims: {claims}",
            userId,
            user.Identity?.Name,
            email,
            user.Claims);

        _logger.LogInformation("Is in role Admin: {response}", user.IsInRole("Admin"));
        _logger.LogInformation("Is in role Guest: {response}", user.IsInRole("Guest"));

        // Perform other actions here

        _hostApplicationLifetime.StopApplication();
    }
    catch (Exception ex)
    {
        _logger.LogError("Error: {message}", ex.Message);
        Environment.Exit(1);
    }
}
```

This will represent the main functionality of the console application.
We first authenticate an external user in `AuthenticateExternalUserAsync` and if authentication was successful we display some user information including User ID, Email, and check to see what roles the user may be a part of.
Finally, `_hostApplicationLifetime.StopApplication()` is called to indicate that the application should exit.

If any exceptions are raised then the application is terminated with a non-zero exit code.

### AuthenticateExternalUserAsync Function

```csharp
private async Task<ClaimsPrincipal> AuthenticateExternalUserAsync(CancellationToken stoppingToken)
{
    _logger.LogInformation("Authenticating with {authority}...", _authSettings.Authority);

    OpenIdConnectConfiguration openIdConfiguration = await RetrieveOpenIdConnectConfigurationAsync(stoppingToken);
    string codeVerifier = Base64UrlEncoder.Encode(RandomNumberGenerator.GetBytes(32));
    int redirectUriPort = GetRedirectUriPort();
    string authorizationCode = await RequestAuthorizationCodeAsync(redirectUriPort, codeVerifier, openIdConfiguration, stoppingToken);
    OpenIdConnectMessage tokenResponse = await RequestTokenAsync(redirectUriPort, authorizationCode, codeVerifier, openIdConfiguration, stoppingToken);
    ClaimsPrincipal claimsPrincipal = ValidateToken(tokenResponse.IdToken, _authSettings.ClientId, openIdConfiguration);
    return claimsPrincipal;
}
```

The AuthenticateExternalUserAsync function follows the OpenID Connect authentication workflow.
The steps of the workflow are broken down into individual methods.

First, we retrieve the OpenID Connect configuration information in `RetrieveOpenIdConnectConfigurationAsync`.
We generate a random `codeVerifier` value that will be used to protect our authorization request from interception which we will discuss in more detail in `RequestAuthorizationCodeAsync` and `RequestTokenAsync`.  For now we just need to know that it is a secure random 32 byte value encoded in URL safe Base64 encoding.
We request the authorization code in `RequestAuthorizationCodeAsync` and then immediately use it to request ID and Access Tokens in `RequestTokenAsync`.
Finally, we call `ValidateToken` to validate the ID Token and turn it into a Dotnet Identity `ClaimsPrincipal` that is returned representing the authenticated user.

### RetrieveOpenIdConnectConfigurationAsync Function

OpenID Connect uses multiple endpoints that are called to perform the various steps of the protocol.
These usually are easy to guess based on the base URI of the authentication server.

For example, if our authentication server base URL was `https://dev-MyDotnetApplication.us.auth0.com` then you could assume that the Authorization Endpoint would be `"https://dev-MyDotnetApplication.us.auth0.com/authorize` and the Token Endpoint would be `https://dev-MyDotnetApplication.us.auth0.com/oauth/token`.  But this can be error prone and it is a pain to have to keep track of all of the various endpoint URLs individually.  Instead, the [OpenID Connect protocol Section 4](https://openid.net/specs/openid-connect-discovery-1_0.html) provides a well-known URL `https://{Base URL}/.well-known/openid-configuration` to the authorization server base URL like `https://dev-MyDotnetApplication.us.auth0.com/.well-known/openid-configuration`.  This endpoint returns a JSON object that contains properties for all of the various endpoints and information we will need:

```json
{
    "issuer": "https://dev-MyDotnetApplication.us.auth0.com/",
    "authorization_endpoint": "https://dev-MyDotnetApplication.us.auth0.com/authorize",
    "token_endpoint": "https://dev-MyDotnetApplication.us.auth0.com/oauth/token",
    "jwks_uri": "https://dev-MyDotnetApplication.us.auth0.com/.well-known/jwks.json",
    ...
}
```

We just need to send an HTTP GET request to the configuration endpoint and then use the URLs in the JSON `authorization_endpoint` and `token_endpoint` properties.  The JSON `jwks_uri` property contains a URL used to retrieve the JSON Web Keys that contains the Public Keys needed to verify the tokens that we receive from the token endpoint.

Microsoft has already provided classes that maintain and cache this configuration data for us.  The `OpenIdConnectConfigurationRetriever` and `OpenIdConnectConfiguration` classes retrieve and store the OpenID Connect configuration data for us.  We can then just use the `AuthorizationEndpoint`, `TokenEndpoint` and `SigningKeys` properties of the retrieved `OpenIdConnectConfiguration` object when we need those values.  This makes `RetrieveOpenIdConnectConfigurationAsync` really trivial:

```csharp
private async Task<OpenIdConnectConfiguration> RetrieveOpenIdConnectConfigurationAsync(CancellationToken cancellationToken)
{
    var uriBuilder = new UriBuilder(_authSettings.Authority)
    {
        Path = "/.well-known/openid-configuration"
    };
    var uri = uriBuilder.ToString();
    _logger.LogInformation("Retrieving configuration from {endpoint}...", uri);
    var configurationManager = new ConfigurationManager<OpenIdConnectConfiguration>(
        uri,
        new OpenIdConnectConfigurationRetriever(),
        new HttpDocumentRetriever());
    return await configurationManager.GetConfigurationAsync(cancellationToken);
}
```

### GetRedirectUriPort Function

```csharp
private int GetRedirectUriPort()
{
    // Use a specific port if configured since Auth0 does not support randomly assigned ports
    if (_authSettings.RedirectUriPort != 0)
    {
        return _authSettings.RedirectUriPort;
    }
    // Retrieve an assigned port from the operating system
    var listener = new TcpListener(IPAddress.Loopback, 0);
    listener.Start();
    var port = ((IPEndPoint)listener.LocalEndpoint).Port;
    listener.Stop();
    return port;
}
```

This function is generally used to get a randomly assigned port from the operating system that will be used for the Redirect URI listener.
Here we just attempt to open a TCP Listener with port 0 so that the operating system will assign us a port.
We then close the listener and then use that port for our HTTP Listener.
The technique was borrowed from the [Google OAuth for Apps: Sample Console Application for Windows](https://github.com/googlesamples/oauth-apps-for-windows/tree/master/OAuthConsoleApp).


[RFC 8252 Section 7.3](https://datatracker.ietf.org/doc/html/rfc8252#section-7.3) states:

    The authorization server MUST allow any port to be specified at the time of the request for loopback IP redirect URIs, to accommodate clients that obtain an available ephemeral port from the operating system at the time of the request.

Unfortunately, [Auth0 does not currently support randomly assigned ports](https://community.auth0.com/t/random-local-ports-on-redirect-uri/28623/9) so you must specify a port in the Authentication settings and it must match the port used when setting up the Auth0 Callback URLs mentioned previously.
For other authentication servers that support randomly defined ports, leave the `RedirectUriPort` setting as 0.

### GetRedirectUri Function

```csharp
private string GetRedirectUri(int port)
{
    return $"http://{IPAddress.Loopback}:{port}/{_authSettings.RedirectUriPath}";
}
```

This function just returns a local redirect url based with the specified port and configured path.

For our configuration with `RedirectUriPort` = 49152 and `RedirectUriPath` = "callback" the resulting Redirect URI would be `http://127.0.0.1:49152/callback`

### RequestAuthorizationCodeAsync Function

This function has a lot of code but isn't really doing anything complicated.
At a high level it does the following:

- Generates an authorization URL
- Opens an HTTP Listener on the Redirect URI
- Opens the authorization URL in the default system browser
- Waits for the browser to redirect to the Redirect URI
- Validates the response
- Returns the authorization token

```csharp
private async Task<string> RequestAuthorizationCodeAsync(int redirectUriPort, string codeVerifier, OpenIdConnectConfiguration openIdConfiguration, CancellationToken stoppingToken)
{
    _logger.LogInformation("Requesting authorization code from {endpoint}...", openIdConfiguration.AuthorizationEndpoint);

    var authorizationCode = string.Empty;
    var requestState = Base64UrlEncoder.Encode(RandomNumberGenerator.GetBytes(16));
    var codeChallenge = Base64UrlEncoder.Encode(SHA256.HashData(Encoding.ASCII.GetBytes(codeVerifier)));

    _logger.LogInformation("Starting HTTP Listener...");
    using var listener = new HttpListener();
    listener.Prefixes.Add($"http://{IPAddress.Loopback}:{redirectUriPort}/");
    listener.Start();

    var redirectUri = GetRedirectUri(redirectUriPort);
    var parameters = new Dictionary<string, string>
    {
        { "response_type", "code" },
        { "client_id", _authSettings.ClientId },
        { "redirect_uri", redirectUri },
        { "scope", "openid email profile" },
        { "state", requestState },
        { "code_challenge", codeChallenge },
        { "code_challenge_method", "S256" },
    };

    if (!string.IsNullOrEmpty(_authSettings.Audience))
    {
        parameters.Add("audience", _authSettings.Audience);
    }

    var url = BuildUrl(openIdConfiguration.AuthorizationEndpoint, parameters);

    _logger.LogInformation("Opening default browser...", url);
    _logger.LogDebug("Request URL: {request}", url);
    if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
    {
        Process.Start(new ProcessStartInfo
        {
            FileName = url,
            UseShellExecute = true,
        });
    }
    else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
    {
        Process.Start("xdg-open", url);
    }
    else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
    {
        Process.Start("open", url);
    }
    else
    {
        throw new NotSupportedException("Cannot open default browser");
    }

    _logger.LogInformation("Waiting for response from browser...");
    var context = await listener.GetContextAsync().WaitAsync(TimeSpan.FromMinutes(2), stoppingToken);
    var request = context.Request;
    _logger.LogDebug("Response URL: {url}", request.Url);

    string? error = null;
    string? errorDescription = null;
    if (!redirectUri.Equals($"http://{request.Url?.Host}:{request.Url?.Port}{request.Url?.AbsolutePath}"))
    {
        error = "Invalid Response";
        errorDescription = "The response does not match the redirect URI";
    }

    string responseText;
    error ??= request.QueryString["error"];
    if (error != null)
    {
        errorDescription ??= request.QueryString["error_description"] ?? "Unknown Error";
        _logger.LogError("Authorization request failed: \"{error}\": {description}", error, errorDescription);
        responseText = "Authorization request failed";
    }
    else
    {
        authorizationCode = request.QueryString["code"] ?? string.Empty;
        var responseState = request.QueryString["state"];

        if ((requestState != responseState) || string.IsNullOrEmpty(authorizationCode))
        {
            responseText = "Authorization state was not valid";
            _logger.LogError("{response}", responseText);
        }
        else
        {
            responseText = "Authorization code received";
            _logger.LogInformation("{response}", responseText);
        }
    }

    var response = context.Response;
    using (var writer = new StreamWriter(response.OutputStream))
    {
        writer.WriteLine($"<HTML><BODY>{responseText}</BODY></HTML>");
        writer.Flush();
    }

    return !string.IsNullOrEmpty(authorizationCode)
        ? authorizationCode
        : throw new Exception(responseText);
}
```

One important thing to point out here is that `code_challenge` and `code_challenge_method` values are included in the authorization request.
This implements the PKCE workflow covered in the [RFC 7636 Proof Key for Code Exchange by OAuth Public Clients Section 4.1](https://datatracker.ietf.org/doc/html/rfc7636#section-4.1) and is used to prevent malicious interception and tampering of the data.
This value is generated from the `Code Verifier` mentioned earlier that was created by generating 32 bytes of secure random data and then Base64 URL encoding the bytes.
The `Code Challenge` is then prepared using the `S256` `Code Challenge Method` by taking the `Code Verifier` and applying the SHA-256 hashing algorithm and then Base64 URL encoding the result again.

An example generated URL is provided below:

```
https://dev-MyDotnetApplication.us.auth0.com:443/authorize?response_type=code&client_id=OiCPeU0i214x6nJUq4YG4ECUlPOSUAlt&redirect_uri=http%3A%2F%2F127.0.0.1%3A49152%2Fcallback&scope=openid%20email%20profile&state=lZ01ygDKM6JhNC0iwcNLsA&code_challenge=n3KyPPCdoUaY44czXEq_Mb_-k6UqqjscXAV__Z5WjMA&code_challenge_method=S256
```

When the response is received, the application must verify that the URL used matches the Redirect URI and that the state returned in the response matches the state value sent in the authorization request.

An example response is provided below:

```
http://127.0.0.1:49152/callback?code=kBVS3EnU_F-mjPTsKaHLWcz6muM4sxAuowBaEmHn9239t&state=lZ01ygDKM6JhNC0iwcNLsA
```

The value returned in the `code` query string parameter of the URL is then returned as the authorization code.

### BuildUrl Function

This is just a quick helper function that takes a base URL and dictionary of string values and generates a URL with properly encoded query string parameters.

```csharp
private static string BuildUrl(string baseUrl, Dictionary<string, string> queryParameters)
{
    var queryBuilder = new StringBuilder();
    foreach (var pair in queryParameters)
    {
        queryBuilder.Append('&');
        queryBuilder.Append(UrlEncoder.Default.Encode(pair.Key));
        queryBuilder.Append('=');
        queryBuilder.Append(UrlEncoder.Default.Encode(pair.Value));
    }
    var uri = new UriBuilder(baseUrl)
    {
        Query = queryBuilder.ToString().Trim('&')
    };
    return uri.ToString();
}
```

### RequestTokenAsync Function

The authorization code is not very useful on its own.
It is only used for immediately requesting ID and Access tokens using the Token Endpoint and an HTTP Post with specific Form URL Encoded parameters.  
The `authorization_code`, `redirect_uri`, and `code_verifier` are included in the parameters.  
The `code_verifier` is the `Code Verifier` value that was originally generated.
The Authentication Server will use the same `S256` Challenge Method to verify that the `Code Verifier` given is what created the `Code Challenge` when the authorization code was requested.
This allows the authentication server to validate that the token request came from the same client who originated the authorization code request and that nothing was tampered with during transmission.

An example of the HTTP POST Form URL Encoded contents is provided below:

```
grant_type=authorization_code&client_id=OiCPeU0i214x6nJUq4YG4ECUlPOSUAlt&code=kBVS3EnU_F-mjPTsKaHLWcz6muM4sxAuowBaEmHn9239t&redirect_uri=http%3A%2F%2F127.0.0.1%3A49152%2Fcallback&code_verifier=YXlDyKO3oD6Fli-NZSEN4CCHvN5OeBNw0ctAEGFBP1g
```

```csharp
private async Task<OpenIdConnectMessage> RequestTokenAsync(int redirectUriPort, string authorizationCode, string codeVerifier, OpenIdConnectConfiguration openIdConfiguration, CancellationToken stoppingToken)
{
    _logger.LogInformation("Requesting access token from {endpoint}...", openIdConfiguration.TokenEndpoint);
    var parameters = new Dictionary<string, string>
    {
        { "grant_type", "authorization_code" },
        { "client_id", _authSettings.ClientId },
        { "code", authorizationCode },
        { "redirect_uri", GetRedirectUri(redirectUriPort) },
        { "code_verifier", codeVerifier }
    };

    var request = new HttpRequestMessage(HttpMethod.Post, openIdConfiguration.TokenEndpoint)
    {
        Content = new FormUrlEncodedContent(parameters)
    };

    _logger.LogDebug("Request: {request}, Form Parameters: {parameters}", request, parameters);
    var response = _httpClient.Send(request, stoppingToken);
    if (!response.IsSuccessStatusCode)
    {
        throw new Exception($"Token request failed: {response.ReasonPhrase}");
    }

    var json = await response.Content.ReadAsStringAsync(stoppingToken);
    _logger.LogDebug("Response: {json}", json);
    return new OpenIdConnectMessage(json);
}
```

If everything checks out, the authentication server will then respond with the tokens which are then deserialized to an `OpenIdConnectMessage`:

```json
{
    "access_token": "eyJ...MWw",
    "id_token": "eyJ...0kg",
    "scope": "openid profile email",
    "expires_in": 86400,
    "token_type": "Bearer"
}
```

The ID Token is a JWT token that can be decoded using the [JWT.IO Debugger](https://jwt.io).
The token's payload will contain data similar to the following:

```json
{
  "OiCPeU0i214x6nJUq4YG4ECUlPOSUAlt/roles": [
    "Admin"
  ],
  "nickname": "codepenguin",
  "name": "Code Penguin",
  "picture": "https://s.gravatar.com/avatar/7b6...a13?s=480&r=pg&d=https%3A%2F%2Fcdn.auth0.com%2Favatars%2Fco.png",
  "updated_at": "2023-05-11T01:05:37.918Z",
  "email": "email@example.com",
  "email_verified": true,
  "iss": "https://dev-MyDotnetApplication.us.auth0.com/",
  "aud": "OiCPeU0i214x6nJUq4YG4ECUlPOSUAlt",
  "iat": 1684002348,
  "exp": 1684038348,
  "sub": "auth0|640...e06",
  "sid": "qGH...eVbl"
}
```

### ValidateToken Function

This function takes a JWT token and validates it based on the OpenID Connect Configuration.  
The Signing Keys are used to validate that the token was produced by the person holding the corresponding private key.
We set the `RoleClaimType` so that the user roles will be taken from the specific claims that our Auth0 Action added to the ID Token.

If the token is valid, a `ClaimsPrincipal

```csharp
private ClaimsPrincipal ValidateToken(string token, string audience, OpenIdConnectConfiguration openIdConfiguration)
{
    _logger.LogInformation("Validating token...");
    JwtSecurityTokenHandler.DefaultInboundClaimTypeMap.Clear();
    var tokenHandler = new JwtSecurityTokenHandler();
    tokenHandler.InboundClaimTypeMap.Clear();
    var validationParameters = new TokenValidationParameters
    {
        ClockSkew = TimeSpan.Zero,
        IssuerSigningKeys = openIdConfiguration.SigningKeys,
        NameClaimType = "name",
        RequireExpirationTime = true,
        RequireSignedTokens = true,
        RoleClaimType = $"{_authSettings.ClientId}/roles",
        ValidateAudience = true,
        ValidateIssuerSigningKey = true,
        ValidateIssuer = true,
        ValidateLifetime = true,
        ValidAudience = audience,
        ValidIssuer = _authSettings.Authority,
    };
    ClaimsPrincipal claimsPrincipal = tokenHandler.ValidateToken(token, validationParameters, out var validatedToken);
    _logger.LogDebug("Validated token: {token}", validatedToken);
    return claimsPrincipal;
}
```

## Testing out the console application

Execute the console application by calling `dotnet run`.

The system default browser should pop up with a prompt similar to the following:

![Auth0 Authorization Prompt]({{ site.baseurl }}/assets/2023/05/openid-connect-dotnet-desktop-application/auth0_authorization_prompt.png)

The browser will then change to show the message "Authorization code received" if everything was successful.
Returning to the console application will then show information about the authorized user similar to the following:

```shell
info: OpenIdConnectConsoleTest.Worker[0]
      Authenticating with https://dev-MyDotnetApplication.us.auth0.com/...
info: OpenIdConnectConsoleTest.Worker[0]
      Retrieving configuration from https://dev-MyDotnetApplication.us.auth0.com:443/.well-known/openid-configuration...
info: OpenIdConnectConsoleTest.Worker[0]
      Requesting authorization code from https://dev-MyDotnetApplication.us.auth0.com/authorize...
info: OpenIdConnectConsoleTest.Worker[0]
      Starting HTTP Listener...
info: OpenIdConnectConsoleTest.Worker[0]
      Opening default browser...
info: OpenIdConnectConsoleTest.Worker[0]
      Waiting for response from browser...
info: OpenIdConnectConsoleTest.Worker[0]
      Authorization code received
info: OpenIdConnectConsoleTest.Worker[0]
      Requesting access token from https://dev-MyDotnetApplication.us.auth0.com/oauth/token...
info: OpenIdConnectConsoleTest.Worker[0]
      Validating token...
info: OpenIdConnectConsoleTest.Worker[0]
      Authenticated as Id: auth0|640...e06 Name: Code Penguin Email: email@example.com Claims: OiCPeU0i214x6nJUq4YG4ECUlPOSUAlt/roles: Admin, nickname: codepenguin, name: Code Penguin, picture: https://s.gravatar.com/avatar/7b6...a13?s=480&r=pg&d=https%3A%2F%2Fcdn.auth0.com%2Favatars%2Fco.png, updated_at: 2023-05-11T01:05:37.9180000Z, email: email@example.com, email_verified: true, iss: https://dev-MyDotnetApplication.us.auth0.com/, aud: OiCPeU0i214x6nJUq4YG4ECUlPOSUAlt, iat: 1684006121, exp: 1684042121, sub: auth0|640...e06, sid: qGH...Vbl
info: OpenIdConnectConsoleTest.Worker[0]
      Is in role Admin: True
info: OpenIdConnectConsoleTest.Worker[0]
      Is in role Guest: False
info: Microsoft.Hosting.Lifetime[0]
      Application is shutting down...
```

## Conclusion

Using the OpenID Connect Authorization Code Flow we can validate external user credentials in a native desktop application.
The system default browser is used so that the user's credentials are not leaked to the application.
If the user is already signed in with their authentication provider, the application is immediately logged in without additional interaction if the user has already authorized the application previously.
This greatly increases the speed and security of authenticating a user in native desktop applications.

Full source code for this console application: <https://github.com/CodePenguin/codepenguin.github.io/tree/main/assets/2023/05/openid-connect-dotnet-desktop-application/OpenIdConnectConsoleTest>

If you have questions or comments, feel free to post in the discussion: <https://github.com/CodePenguin/codepenguin.github.io/discussions/5>